Karol Pokorski zadanie 1: sprowadza się do znalezienia najdłuższego palindromicznego sufiksu, należy dopisać pozostałe literki w odwrotnej kolejności. jak znaleźć ów sufiks? tysiące sposobów: algorytm Manachera (nie było na wykładzie), haszowanie od prawej i od lewej, KMR lub choćby bierzesz słowo w odwrotnej kolejności i sklejasz z słowem w normalnej kolejności, znajdujesz prefiksosufiks jak w KMP i to jest długość owego sufiksu, którego szukasz: przykład: abaab -> baaba#abaab -> prefiksosufiks: baab -> trzeba dopisać literkę a

Karol Pokorski zadanie 2: zmienne to wierzchołki grafu, krawędzie reprezentują równości. Jeśli istnieje nierówność między x_i a x_j i istnieje ścieżka (przypominam krawędzie są tylko dla równości) między x_i a x_j to odpowiedź brzmi NIE (nie istnieje przyporządkowanie). Jak to szybko sprawdzać? Dokładanie krawędzi do grafu => Union(x_i, x_j), Sprawdzanie czy jest ścieżka między x_i, a x_j => Find(x_i) = Find(x_j), ewentualnie jeśli kogoś boli log* w złożoności -> dfs (przeszukiwanie w głąb), interesują Cię tylko krawędzie drzewowe (tzn. te po których fizycznie przeszedłeś, a nie olałeś bo już był visited), jak policzysz czasy preorder i postorder łatwo sprawdzić czy u jest w poddrzewie v -> a zatem łącznie wychodzi czas liniowy, ale gorsza złożoność pamięciowa (O(n+m) zamiast O(n))

Karol Pokorski zadanie 3: dynamik -> stanem jest (x, y, k) -> (x,y) pozycja, k - liczba użytych już ruchów pionowych, teraz trzeba się dziebko namęczyć z kolejnością analizy tych stanów (było już takie zadanie na liście ćwiczeniowej) lub olać sprawę i puścić dijkstrę na tych stanach (wierzchołkami są stany, a krawędziami przejścia między nimi, waga krawędzi = koszt przejścia do nowego stanu ze starego)

Paweł Adamczyk A jesli chodzi o zadanie 3, to pomysl byl chyba taki, zeby stworzyc tablice optymalnych wartosci dojscia na pole [ i ][ j ], czyli B[1..i..n][1..j..n][0...k] gdzie ostatnia wspolrzedna mowi nam o pozostalych mozliwych krokach w pionie. Dalej algorytm analogicznie jak w zadaniu o stokrotkach z listy (gdzie dopuszczalne byly kroki w gore i w dol), najpierw wyznaczamy optymalne rozwiazania dla pol, biorac pod uwage tylko kroki z lewej strony tego pola, pozniej lecimy od gory do dolu, aktualizujac tablice dla krokow pionowych, po czym to samo idac od dolu do gory. Wynikiem oczywiscie jest max z ostatniej kolumny.